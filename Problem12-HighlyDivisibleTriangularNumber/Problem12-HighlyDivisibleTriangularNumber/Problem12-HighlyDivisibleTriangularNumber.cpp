// Problem12-HighlyDivisibleTriangularNumber.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <vector>
#include <iostream>
#include <tuple>
#include <algorithm>
#include <thread>
#include <future>
#include <iomanip>
#include <stdio.h>
#include <cstdint>

/*
Problem 12:
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1,3
6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?*/


std::vector<uint64_t> GetDivisors(uint64_t n)
{
	std::vector<uint64_t> result;
	
	result.push_back(1);

	for (uint64_t i = 2; i < n; ++i)
	{
		if (n % i == 0)
			result.push_back(i);
	}

	result.push_back(n);

	return result;
}

uint64_t GetTriangularNumber(uint64_t n)
{
	return (n * (n + 1)) / 2;
}

std::tuple<uint64_t, std::vector<uint64_t>> GetDivisorsForTriangularNumber(uint64_t n)
{
	auto triangularN = GetTriangularNumber(n);
	return std::tuple<uint64_t, std::vector<uint64_t>>(triangularN, GetDivisors(triangularN));
}

uint64_t NumberOfDivisors(const std::tuple<uint64_t, std::vector<uint64_t>>& input)
{
	return std::get<1>(input).size();
}

std::tuple<uint64_t, std::vector<uint64_t>> GetTriangularNumberWithOverNDivisors(uint64_t n)
{

	uint64_t i = n;
	std::tuple<uint64_t, std::vector<uint64_t>> result;
	bool done = true;
	do
	{
		done = true;

		auto future1 = std::async(GetDivisorsForTriangularNumber, i);
		auto future2 = std::async(GetDivisorsForTriangularNumber, i + 1);
		auto future3 = std::async(GetDivisorsForTriangularNumber, i + 2);
		auto future4 = std::async(GetDivisorsForTriangularNumber, i + 3);
		auto result1 = future1.get();
		auto result2 = future2.get();
		auto result3 = future3.get();
		auto result4 = future4.get();
		
		if (NumberOfDivisors(result1) >= n)
		{
			result = result1;
		}
		else if (NumberOfDivisors(result2) >= n)
		{
			result = result2;
		}
		else if (NumberOfDivisors(result3) >= n)
		{
			result = result3;
		}
		else if (NumberOfDivisors(result4) >= n)
		{
			result = result4;
		}
		else
		{
			done = false;
			i += 4;
		}
	} while (!done);

	return result;

}

int _tmain(uint64_t argc, _TCHAR* argv[])
{
	auto result = GetTriangularNumberWithOverNDivisors(500);

	auto number = std::get<0>(result);
	auto divisors = std::get<1>(result);
	std::cout << "Triangular number = " << number << std::endl << std::endl;
	printf("Divisors (%d) : \n", divisors.size());
	std::for_each(divisors.begin(), divisors.end(), [](uint64_t divisor){std::cout << divisor << " "; });
	std::cout << std::endl;
	return 0;
}

